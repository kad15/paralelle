\section{Algorithmes de Dijkstra et A*}


\paragraph{Algorithmes de Dijkstra : }Edgser Wybe Dijkstra (EWD), Physicien Néerlandais reconverti à l'informatique en 1955, a proposé en 1959 un algorithme de recherche de chemin minimum 
dans un graphe  dont  la complexité est en O(n). 

\begin{figure}[htp]
  \centering
  \includegraphics[width=4cm]{images/Edsger_Wybe_Dijkstra}
  \caption{Edgser Wybe Dijkstra (1930-2002)}
  \label{fig:une-autre-image}
\end{figure}

On doit à Dijkstra, qui avait la réputation d'avoir mauvais caractère et qui était notoirement  allergique au ``GOTO'',
quelques citations\footnote{source : \url{https://fr.wikipedia.org/wiki/Edsger_Dijkstra}} telles que :


\begin{quote}
\textit{« Il est pratiquement impossible d'enseigner la bonne programmation aux étudiants 
qui ont eu une exposition antérieure au BASIC : comme programmeurs potentiels, 
ils sont mentalement mutilés, au-delà de tout espoir de régénération. »}
\end{quote}

\begin{quote}
\textit{« Le plus court chemin d'un graphe n'est jamais celui que l'on croit, 
il peut surgir de nulle part, et la plupart du temps, il n'existe pas. »}
\end{quote}

\begin{quote}
\textit{« La programmation par objets est une idée exceptionnellement mauvaise qui ne pouvait naître qu'en Californie. »}
\end{quote}


L'algorithme donne le plus court chemin de la source à \textit{tous les sommets} d'un graphe 
connexe pondéré (orienté ou non) dont le poids lié aux arêtes est positif ou nul.



%  \cite{Roque2012,Roque2012b,Roque2012c,Roque2012d}. 
 


\begin{figure}[htp]
  \centering
  \includegraphics[width=15cm]{images/algo_dij}
  \caption{Exemple de calcul des plus courts chemins à partir du noeud A.}
  \label{fig:graph_dij}
\end{figure}

Sans entrer dans les détails d'implémentation que l'on trouve nombreuses sur la toile et dans la littérature, l'algorithme de Dijkstra est 
un algorithme glouton qui utilise l'hypothèse qu'une décision prise sur la base
d'un critère d'optimalité locale conduira à un optimum global. Ainsi, à chaque itération, l'algorithme choisit, parmi les noeuds non traités, le noeud
du réseau dont la distance au noeud de départ est la plus faible. Ainsi, dans l'image \ref{fig:graph_dij}, on voit que le plus court chemin pour aller de A à C
est égal à 7. On détermine ensuite de proche en proche le chemin le plus court grâce à la mémorisation des noeuds précédents. Ici, C à pour ``previous vertex'' E, 
E -> D et D -> A. Le plus court chemin pour aller de A à C est donc ADEC. On utilise la même technique pour déterminer tous les chemins optimaux 
d'origine A. Mais on peut n'avoir besoin que du calcul du chemin entre 2 sommets. De plus, la myopie de l'algorithme limite forcément ses performances. D'où l'idée
d'utiliser une heuristique visant à guider les choix locaux. Ce qui nous amène à l'algorithme A* présenté brièvement dans la suite.

% \begin{figure}[htp]
%   \centering
%   \input{images/tikz_diagram}
%   \caption{Exemple de diagramme TikZ.}
%   \label{fig:une-image}
% \end{figure}
\paragraph{Algorithme A* : }

A* est l'algorithme qu'on utilise intuitivement pour se déplacer d'un enddroit à un autre dans une ville
connaissant la direction à prendre. Grâce à cette information supplémentaire, A* va privilégier le noeud qui minimise 
la somme de la distancce déjà parcourue et de la distance estimée restant à parcourir qui sera ici la distance à vol d'oiseau.


Cet algorithme a été proposé pour la première fois 
par Peter E. Hart, Nils John Nilsson et Bertram Raphael
en 1968. Il s'agit d'une extension de l'algorithme de Dijkstra et s'applique comme ce dernier
à des graphes munis d'une distance positive. En outre, A* ne teste pas tous les chemins ; il ne fournit donc
qu'un des meilleurs chemins. A* est cependant très performant dans le cas où le graphe comporte une faible densité de noeuds 
mais pas ou peu efficace dans le cas de parcours de labyrinthes par exemple.


Il faut donc choisir, en fonction du problème, une heuristique h, c'est à dire ici une fonction qui estime la distance 
restante entre chaque noeud et l'arrivée, estimation par défaut qui ne doit jamais surestimer cette distance. 
La précision du résultat final dépendra de la précision de l'estimation.
On peut citer les fonctons estimatrices suivantes :  la distance euclidienne (norme 2) ou à ``vol d'oiseau'' déjà citée 
et la distance de Manhattan (norme 1) qui, sur une grille, correspond à la somme des cases verticales et horizontales
qui sépare le position courante de l'arrivée. Les deux distances sont utilisables dans A* car elles sous-estiment
la distance à l'arrivée.


A chaque étapes, l'algorithme calcule g , la distance déjà parcourue pour chaque noeud n non visité puis
la fonction f(n) = g(n) + h(n). Le noeud sélectionné est celui pour lequel f(n) est minimale.




\paragraph{Utilisation}

Comment les utiliser pour transférer de façon optimale une donnée d'un noeud à un autre. ?????

ci dessous une proposition de draft à discuter ou compléter au besoin
à l'aide d'un complément de bibliographie.


Dijkstra est utilisé dans le routage dynamique OSPF, on peut donc envisager optimiser un réseau
de noeuds distribués en permettant l'ajout d'un noeud et sa prise en compte automatique par le réseau.

Quant à l'algorithme A*, il permettrait de déterminer un chemin point à point optimal utilisé ensuite par exemple pour créer une liaison par commutation de circuit intéressante si la taille des données qui doivent être échangées est importante.




% \begin{table}[ht]
%   \begin{center}
%     \begin{tabular}{|c|c|c|c|c|}
%       \hline
%       & $h(t,\tau)$ & $S_{\OP{H}}^{(\alpha)} (f,\tau)$ & $L_{\OP{H}}^{(\alpha)} (\nu,t)$ & $H^{(\alpha)}(f,\nu)$ \\
%       \hline
%       LTI & $q(\tau)$ & $q(\tau) \delta(f)$ & $Q(\nu)$ & $Q(\nu) \delta(\nu-f)$ \\
%       \hline
%       LFI & $m(t) \delta(\tau)$ & $M(f) \delta(\tau)$ & $m(t)$ & $M(f)$\\
%       \hline
%       identité & $\delta(t)$ & $\delta(f)\delta(\tau)$ & $1$ & $\delta(\nu-f)$\\
%       \hline
%     \end{tabular}
%     \caption{Exemple de tableau.}
%     \label{tab:un-tableau}
%   \end{center}
% \end{table}


% \begin{figure}[htp]
%   \centering
%   \includegraphics[width=4cm]{images/bitmap_image}
%   \caption{Exemple d'image au format JPG.}
%   \label{fig:une-autre-image}
% \end{figure}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "isae-report-template"
%%% End: 